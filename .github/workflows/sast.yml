# .github/workflows/sast.yml

name: Seguridad SAST + Despliegue Seguro (Docker Compose)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  seguridad:
    name: Ejecutar SAST (Bandit + Semgrep)
    runs-on: ubuntu-latest
    steps:
      - name: Clonar repo
        uses: actions/checkout@v3

      - name: Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Instalar dependencias SAST
        run: |
          pip install bandit semgrep

      - name: Ejecutar Bandit (backend)
        run: |
          bandit -r backend/ -f txt -o bandit_resultados.txt || true

      - name: Ejecutar Semgrep (backend y frontend)
        run: |
          semgrep scan \
            --config "p/ci" \
            --include 'backend/**/*.py' \
            --include 'frontend/**/*.[jt]s' \
            --include 'frontend/**/*.[jt]sx' \
            --include 'frontend/Dockerfile' \
            --include 'backend/Dockerfile' \
            --verbose \
            -o semgrep_resultados.txt

      - name: Subir artefactos SAST
        uses: actions/upload-artifact@v4
        with:
          name: resultados-sast
          path: |
            bandit_resultados.txt
            semgrep_resultados.txt

  docker-compose-test:
    name: Levantar Docker Compose + Smoke Test
    runs-on: ubuntu-latest
    needs: seguridad

    # ——————————————————————————————————————————————————————————————————————
    # Inyectamos todos los secretos que tu docker-compose requiere
    # ——————————————————————————————————————————————————————————————————————
    env:
      # URL de la base de datos (ej.: mysql://user:pass@host:port/db)
      DATABASE_URL:         ${{ secrets.DATABASE_URL }}
      # Credenciales AWS (aunque sean dummy, para que no falle Docker Compose)
      AWS_ACCESS_KEY_ID:    ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN:    ${{ secrets.AWS_SESSION_TOKEN }}
      # Claves Stripe (pueden ser de prueba)
      STRIPE_SECRET_KEY:    ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}

    steps:
      - name: Clonar el repositorio
        uses: actions/checkout@v3

      - name: Instalar Docker Compose
        run: |
          sudo apt-get update
          sudo apt-get install -y docker-compose

      - name: Crear .env para CI (variables dummy / secrets)
        run: |
          # NOTA: esto crea .env en el directorio raíz del repositorio (donde está docker-compose.yml)
          echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"      >> .env
          echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" >> .env
          echo "AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}"      >> .env
          echo "STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}"      >> .env
          echo "STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}" >> .env
          # Si necesitas más variables (SMTP, URLs, etc.), añádelas aquí:
          # echo "OTRA_VAR=${{ secrets.OTRA_VAR }}" >> .env

      - name: Levantar contenedores con Docker Compose
        run: |
          # Primero bajamos contenedores huérfanos (si hubiera alguno) — ignoramos errores
          docker-compose -f docker-compose.yml down --remove-orphans || true

          # Ahora levantamos en segundo plano, usando el .env que acabamos de generar
          docker-compose -f docker-compose.yml up -d --build

      - name: Esperar a que los servicios estén listos
        run: |
          # Ajusta este sleep según el arranque de tu BD/backend (p. ej.: 30 segundos)
          sleep 30

      - name: Verificar contenedores activos (opcional, para debug)
        run: |
          docker ps -a

      - name: Smoke test → /docs (dentro del contenedor)
        run: |
          # Hacemos un curl desde dentro del contenedor “backend”
          docker-compose exec backend \
            sh -c "curl -o /dev/null -s -w \"%{http_code}\" http://127.0.0.1:8000/docs" \
            > respuesta_docs.txt
          DOC_CODE=$(cat respuesta_docs.txt)
          echo "→ Código HTTP /docs dentro del contenedor: $DOC_CODE"
          if [ "$DOC_CODE" != "200" ]; then
            echo "Error: /docs devolvió $DOC_CODE (dentro del contenedor)."
            docker-compose logs backend || true
            exit 1
          fi

      - name: Smoke test → /openapi.json (dentro del contenedor)
        run: |
          docker-compose exec backend \
            sh -c "curl -o /dev/null -s -w \"%{http_code}\" http://127.0.0.1:8000/openapi.json" \
            > respuesta_openapi.txt
          OAPI_CODE=$(cat respuesta_openapi.txt)
          echo "→ Código HTTP /openapi.json dentro del contenedor: $OAPI_CODE"
          if [ "$OAPI_CODE" != "200" ]; then
            echo "Error: /openapi.json devolvió $OAPI_CODE (dentro del contenedor)."
            docker-compose logs backend || true
            exit 1
          fi

      - name: (Opcional) Mostrar logs del backend en caso de fallo
        if: failure()
        run: |
          echo "===== LOGS DEL CONTENEDOR BACKEND ====="
          docker-compose logs backend || true

      - name: Bajar contenedores Docker Compose
        if: always()
        run: |
          docker-compose -f docker-compose.yml down --remove-orphans

